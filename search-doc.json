[{"title":"Glossary","type":0,"sectionRef":"#","url":"/modelica-buildings-templates/more/glossary","content":"","keywords":"","version":"Next"},{"title":"Templating​","type":1,"pageTitle":"Glossary","url":"/modelica-buildings-templates/more/glossary#templating","content":"","version":"Next","tagName":"h2"},{"title":"System​","type":1,"pageTitle":"Glossary","url":"/modelica-buildings-templates/more/glossary#system","content":"See below. ","version":"Next","tagName":"h3"},{"title":"Configuration​","type":1,"pageTitle":"Glossary","url":"/modelica-buildings-templates/more/glossary#configuration","content":"A system configuration corresponds to the specification of the type and layout of the equipment and the corresponding control logic. Systems with different capacities may have the same configuration, provided they have the same control software and hardware type. ","version":"Next","tagName":"h3"},{"title":"Parameterization​","type":1,"pageTitle":"Glossary","url":"/modelica-buildings-templates/more/glossary#parameterization","content":"By parameterization we mean all possible class modifications, such as changing parameter values and redeclaring components or classes, which we refer to as class parameterization. ","version":"Next","tagName":"h3"},{"title":"Structural and value parameters​","type":1,"pageTitle":"Glossary","url":"/modelica-buildings-templates/more/glossary#structural-and-value-parameters","content":"We use the term structural parameters if a parameter affects the number and structure of the equations, and value parameters if they do not. An example of a structural parameter is a parameter used to specify an array size. ","version":"Next","tagName":"h3"},{"title":"Template​","type":1,"pageTitle":"Glossary","url":"/modelica-buildings-templates/more/glossary#template","content":"A template, or template class, is defined as a Modelica model that can be parameterized (as defined above) to represent a particular system configuration. ","version":"Next","tagName":"h3"},{"title":"HVAC Systems​","type":1,"pageTitle":"Glossary","url":"/modelica-buildings-templates/more/glossary#hvac-systems","content":"","version":"Next","tagName":"h2"},{"title":"Source, Load​","type":1,"pageTitle":"Glossary","url":"/modelica-buildings-templates/more/glossary#source-load","content":"We adopt the definitions from ASHRAE (2021) Section 5.1.19.1. A component is a “source” if it provides resources to a downstream component, such as a chiller providing chilled water (CHW) to an AHU. A component is a “load” if it receives resources from an upstream component, such as an AHU that receives CHW from a chiller. The same component may be both a load (receiving resources from an upstream source) and a source (providing resources to a downstream load). ","version":"Next","tagName":"h3"},{"title":"Component, System​","type":1,"pageTitle":"Glossary","url":"/modelica-buildings-templates/more/glossary#component-system","content":"We adopt the definitions from ASHRAE (2021) Section 5.1.19.1. A set of components is a system if they share a load in common (i.e., collectively act as a source to downstream equipment, such as a set of chillers in a lead/lag relationship serving air handlers). Each air handler constitutes its own separate system because they do not share a load in common. Each AHU is a load to the CHW pump system and a source to its own VAV boxes.Each VAV box constitutes its own system because they do not share a load in common. Each VAV box is a load to its AHU only (no relationship to the other AHUs) and a source to the rooms that it serves. ","version":"Next","tagName":"h3"},{"title":"Command​","type":1,"pageTitle":"Glossary","url":"/modelica-buildings-templates/more/glossary#command","content":"Command is used for the DO signal sent to switch On/Off an equipment. Abbreviated as y1&lt;instance-name&gt; See also Enable. ","version":"Next","tagName":"h3"},{"title":"Enable​","type":1,"pageTitle":"Glossary","url":"/modelica-buildings-templates/more/glossary#enable","content":"For VFDs, Enable is a special contact on the VFD panel typically hardwired to a relay logic for safety (see ASHRAE (2021) Figure A-9 for example). This is not the same as the DO point that actually starts the equipment (On/Off command or Start signal) which is wired to VFD Run contact. Enable is used differently for an equipment with built-in control (e.g. chiller or boiler) where the On/Off command is wired to the Enable contact on the control panel (see ASHRAE (2021) Section 4.11.1). There is no Run contact in that case: Enable is used in lieu of Run. Abbreviated as y1&lt;instance-name&gt; ","version":"Next","tagName":"h3"},{"title":"Status​","type":1,"pageTitle":"Glossary","url":"/modelica-buildings-templates/more/glossary#status","content":"Status is used for the current On/Off state of a device as reported by the hardware itself. It is thus a DI signal returned by an equipment that can be switched On and Off such as a pump, fan or chiller. Abbreviated as y1&lt;instance-name&gt;_actual For 2-position actuators: open or closed end switch status is used. Abbreviated as y1&lt;instance-name&gt;_actual and y0&lt;instance-name&gt;_actual for open and closed end switch status, respectively ","version":"Next","tagName":"h3"},{"title":"Commanded (Position | Speed)​","type":1,"pageTitle":"Glossary","url":"/modelica-buildings-templates/more/glossary#commanded-position--speed","content":"Used for the AO signal sent to an equipment. Abbreviated as y&lt;instance-name&gt; ","version":"Next","tagName":"h3"},{"title":"Position Feedback​","type":1,"pageTitle":"Glossary","url":"/modelica-buildings-templates/more/glossary#position-feedback","content":"Position feedback is used for the AI signal returned by a modulating actuator. Abbreviated as y&lt;instance-name&gt;_actual For two-position actuators, use open or closed end switch status. ","version":"Next","tagName":"h3"},{"title":"Setpoint​","type":1,"pageTitle":"Glossary","url":"/modelica-buildings-templates/more/glossary#setpoint","content":"It is defined as the desired value of the process variable which is controlled. Spelled in one word, that is &quot;setpoint&quot; as opposed to &quot;set point&quot;. Details This varies across ASHRAE’s publications: ASHRAE (2021) uses one word but FUNDAMENTALS OF CONTROL uses two words. Most sources (including Aström’s PID Controllers) use one word though. ","version":"Next","tagName":"h3"},{"title":"Supply, Return, Entering, Leaving​","type":1,"pageTitle":"Glossary","url":"/modelica-buildings-templates/more/glossary#supply-return-entering-leaving","content":"For the attributes pertaining to a quantity, use supply or return, and entering or leaving. ","version":"Next","tagName":"h3"},{"title":"Inlet, Outlet​","type":1,"pageTitle":"Glossary","url":"/modelica-buildings-templates/more/glossary#inlet-outlet","content":"Restrict the use of inlet and outlet for a location, such as inlet sensor or outlet valve. ","version":"Next","tagName":"h3"},{"title":"References","type":0,"sectionRef":"#","url":"/modelica-buildings-templates/more/references","content":"","keywords":"","version":"Next"},{"title":"Published​","type":1,"pageTitle":"References","url":"/modelica-buildings-templates/more/references#published","content":"ASHRAE (2021). Guideline 36 – High-performance sequences of operation for HVAC systems. ASHRAE.​ Gautier, A., Wetter, M., Hu, J., &amp; Tummescheit, H. (In press). HVAC and control templates for the Modelica Buildings library. Proceedings of the 15th International Modelica Conference.​ Modelica Association (2021). Modelica – A unified object-oriented language for systems modeling – Language specification (Version 3.5). https://specification.modelica.org/maint/3.5/MLS.html​ ","version":"Next","tagName":"h2"},{"title":"Internal Resources​","type":1,"pageTitle":"References","url":"/modelica-buildings-templates/more/references#internal-resources","content":"Specification of the Modelica Export​ Specification of the Equipment Schedule​ Specification of Parameter Dialogs​ ","version":"Next","tagName":"h2"},{"title":"Nomenclature","type":0,"sectionRef":"#","url":"/modelica-buildings-templates/more/nomenclature","content":"","keywords":"","version":"Next"},{"title":"Example of Control Point Naming​","type":1,"pageTitle":"Nomenclature","url":"/modelica-buildings-templates/more/nomenclature#example-of-control-point-naming","content":"By way of introduction, here is an example of how the following rules translate into practical nomenclature for the CHW plant template.  ","version":"Next","tagName":"h2"},{"title":"Control Points​","type":1,"pageTitle":"Nomenclature","url":"/modelica-buildings-templates/more/nomenclature#control-points","content":"Damper and valve models take y1 (Boolean) if 2-position, XORy (real, fractional) if modulating return y_actual (real, fractional) for the position feedback (modulating), XORy1_actual (Boolean, open end switch status) and y0_actual (Boolean, closed end switch status) Fan and pump models take y1 for the On/Off command (Boolean, used for constant speed motor starter, and variable speed VFD Run signal), ANDy (optional) for the commanded speed (real fractional or integer, used for variable speed or 2-stage fan motor) return y1_actual (Boolean, status) (See also command in Glossary.) Details Still need to clarify the use of u and y in MBL. Is it in reference to the control system (as I/O points) or in reference to the modeled component (either the process—for a sensor—or the controls)?Is it at all related to control theory as in the diagram below? Obviously not as we would then use u for the controller output and e = ysp - y so something in the y domain for the controller input. ","version":"Next","tagName":"h2"},{"title":"Order of Morphemes​","type":1,"pageTitle":"Nomenclature","url":"/modelica-buildings-templates/more/nomenclature#order-of-morphemes","content":"In the CamelCase instance name: The first morpheme indicates what the instance represents. For example, a controller ctl, a fan fan, a coil coi Details This is motivated by the naming of quantity variables: we would not use SupAirT for the supply air temperature, but rather TAirSup, physical connectors: see port_a. The suffixes stand for the attributes by order of importance. For example, coiCoo for cooling coil, fanSupDra for a supply fan in a draw-through configuration. For a quantity the first suffix shall systematically describe the medium (ChiWat, Air, etc.), the second suffix shall describe the origin of the medium (ChiWatSup, TAirSup, etc.). Exceptions are only allowed if the quantity is a system characteristic for which there is no ambiguity, e.g., dpDamOut_nominal for the OA damper pressure drop (we don’t mention air) or dpValCoiCoo for the cooling coil control valve (we don’t mention CHW). Similarly (exhaustive list): TOut or phiOut (air implied)TZon (air implied)pBui_rel (air implied) All CamelCase morphemes should be used before the first underscore—such as in mAirSup_flow_nominal—with the exception of the physical connectors where we use port_aChiWat. ","version":"Next","tagName":"h2"},{"title":"Do we allow 3-letter capital names such as CHW?​","type":1,"pageTitle":"Nomenclature","url":"/modelica-buildings-templates/more/nomenclature#do-we-allow-3-letter-capital-names-such-as-chw","content":"NO 3-letter capital abbreviations are only allowed—and encouraged—in documentation and description strings. For variable and instance names: Rather use\tInstead of\tTo designateairHan (*)\tAHU\tAir handling unit chiWat (*)\tCHW\tChilled water conWat (*)\tCW\tCondenser water coo\tCT\tCooling tower or dry cooler eco (*)\tWSE\tWaterside economizer heaWat (*)\tHHW\tHeating hot water hex (*)\tHX\tHeat exchanger hotWat (*)\tDHW\tDomestic hot water hp\tHP\tHeat pump hrc\tHRC\tHeat recovery chiller (*) These abbreviations are being used by legacy. If we were to decide today, it would make more sense to rather use lower case abbreviations: chw, cw, hw, dhw, wse, hx, ahu. This is more aligned with the considerations from https://stackoverflow.com/questions/15526107/acronyms-in-camelcase. Tolerated exceptions (by legacy again, today it would make more sense to use lower case abbreviations): COPVAVPLR ","version":"Next","tagName":"h2"},{"title":"Fixed Position or Non-abbreviated Forms​","type":1,"pageTitle":"Nomenclature","url":"/modelica-buildings-templates/more/nomenclature#fixed-position-or-non-abbreviated-forms","content":"_nominal, _min, _max, _actual, _default always at the end Details min and max are attributes of primitive types in Modelica, same as nominal, and should have the same notation, not Min and Max in CamelCase. For design conditions use _nominal not Des _flow for rate per unit of time have_, is_ or use_ for a structural parameter, always at the beginning Details Why not has_? Because “Does it have?”, same for “Does it use?”, but “Is it?” _a and _b for inlet and outlet ports. ","version":"Next","tagName":"h2"},{"title":"Reserved​","type":1,"pageTitle":"Nomenclature","url":"/modelica-buildings-templates/more/nomenclature#reserved","content":"","version":"Next","tagName":"h2"},{"title":"Physical Quantities​","type":1,"pageTitle":"Nomenclature","url":"/modelica-buildings-templates/more/nomenclature#physical-quantities","content":"Pressure: p is used for absolute pressure,p_rel for relative pressure (duct static, building static, etc.),dp for a pressure drop across an equipment or a circuit. Relative humidity: phi From Buildings.UsersGuide.Conventions: Mass fraction Uppercase X denotes mass fraction per total mass.Lowercase x denotes mass fraction per mass of dry air (absolute humidity). TWetBul for wet bulb tip The naming conventions used for variables representing quantities (such as T for temperature) should be used in component names (typically sensors) for the sake of concision. For example, a sensor for supply air temperature should be named TAirSup instead of senTemAirSup. ","version":"Next","tagName":"h3"},{"title":"Various​","type":1,"pageTitle":"Nomenclature","url":"/modelica-buildings-templates/more/nomenclature#various","content":"We systematically use the parameter cap*_nominal to specify a system capacity. Design engineers are used to provide an unsigned number (positive) for both the heating and cooling capacities. However, MBL users are rather accustomed to using Q*_flow_nominal as a signed parameter. So, for consistency with MBL, each template must make a final assignment of Q*_flow_nominal = +/- abs(cap*_nominal) so that this parameter be always available. Nevertheless, cap*_nominal has no min or max attribute so that the user can provide either a signed or an unsigned variable. Example For example, a chiller template would have the following declarations. mo parameter Modelica.Units.SI.HeatFlowRate cap_nominal // No min and max attributes. &quot;Design cooling capacity&quot;; final parameter Modelica.Units.SI.HeatFlowRate Q_flow_nominal(final max=0)= // Final assignment that must be negative. -abs(cap_nominal) &quot;Design cooling heat flow rate&quot;; Copy mo parameter Modelica.Units.SI.HeatFlowRate cap_nominal // No min and max attributes. &quot;Design cooling capacity&quot;; final parameter Modelica.Units.SI.HeatFlowRate Q_flow_nominal(final max=0)= // Final assignment that must be negative. -abs(cap_nominal) &quot;Design cooling heat flow rate&quot;; Copy Set for a set point, always as the last morpheme: so TZonHeaOccSet not TZonHeaSetOcc. The letter n is used to represent a number of something (as opposed to num). The letter y is used to represent a fractional quantity (speed, opening, load) taking 111 as maximum value, e.g., yLoa for PLR. tip Prefer ctl to con for a controller as the latter is too loose: condenser, configuration, etc. Prefer cfg to con for a configuration. Prefer lck to loc for lock-out as the latter is too loose: local, etc. ","version":"Next","tagName":"h3"},{"title":"Legacy Exceptions​","type":1,"pageTitle":"Nomenclature","url":"/modelica-buildings-templates/more/nomenclature#legacy-exceptions","content":"Mainly for consistency with MSL we allow the following variable names. samplePeriod ","version":"Next","tagName":"h2"},{"title":"Guide","type":0,"sectionRef":"#","url":"/modelica-buildings-templates/guide","content":"","keywords":"","version":"Next"},{"title":"Interface Class: What Shall Be Declared?​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#interface-class","content":"","version":"Next","tagName":"h2"},{"title":"Outside Connectors Needed by Any Derived Class​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#outside-connectors-needed-by-any-derived-class","content":"Important All outside connectors must be declared within the interface class—with the suitable conditional instance statements. (Each class extending an interface class shall not declare any outside connector—it may only conditionally remove inherited connectors.) This ensures the plug-compatibility of each derived class, and implies a fixed connectivity structure for each instantiated subsystem model, allowing these instances to be connected to each other without worrying about the actual configuration of each subsystem. This applies to connecting components within a template, or connecting templates to each other to create a whole-building model. Details How does it comply with the Modelica Language Specification? Type compatibility: Each reference is checked, whether it is a valid reference, e.g. the referenced object belongs to or is an instance, where all existing conditional declaration expressions evaluate to true|false, or it is a constant in a package. So checking that the redeclared component is a subtype of the constraining class is done with all the conditional connectors considered present (even if the redeclared component removes them). How does it differ from interface classes in the Modelica Buildings Library? Interface classes are usually implemented with the minimum set of connectors (and other variables) and derived classes extend that set, which ensures type compatibility. See for example: Fluid/Boilers/BaseClasses/PartialBoiler.mo mo extends Interfaces.TwoPortHeatMassExchanger(...); // Interface class used by the model Modelica.Blocks.Interfaces.RealInput y(...) // Additional connector not declared in the interface class &quot;Part load ratio&quot;; Modelica.Blocks.Interfaces.RealOutput T(...) // Additional connector not declared in the interface class &quot;Temperature of the fluid&quot;; Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort // Additional connector not declared in the interface class &quot;Heat port, can be used to connect to ambient&quot;; Copy Fluid/Boilers/BaseClasses/PartialBoiler.mo mo extends Interfaces.TwoPortHeatMassExchanger(...); // Interface class used by the model Modelica.Blocks.Interfaces.RealInput y(...) // Additional connector not declared in the interface class &quot;Part load ratio&quot;; Modelica.Blocks.Interfaces.RealOutput T(...) // Additional connector not declared in the interface class &quot;Temperature of the fluid&quot;; Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort // Additional connector not declared in the interface class &quot;Heat port, can be used to connect to ambient&quot;; Copy ","version":"Next","tagName":"h3"},{"title":"Both the Parameter Record and Locally Accessible Design Parameters​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#both-the-parameter-record-and-locally-accessible-design-parameters","content":"The parameter record is for propagation of design and operating parameters across the instance tree. The local design parameter declarations ensure that a standard set of parameters is available in any template or component, for any configuration. (For example, an evaporator coil still has mChiWat_flow_nominal defined with a final assignment to 0.) This way, one can easily compute the sum of a quantity over a set of instances. (For example, the total CHW flow rate over all terminal units.) Most of the local design parameters have final assignments to the parameters from the record. Example Templates/AirHandlersFans/Interfaces/PartialAirHandler.mo mo final parameter Modelica.Units.SI.MassFlowRate mAirSup_flow_nominal= dat.mAirSup_flow_nominal &quot;Supply air mass flow rate&quot; annotation (Dialog(group=&quot;Nominal condition&quot;)); final parameter Modelica.Units.SI.MassFlowRate mAirRet_flow_nominal= dat.mAirRet_flow_nominal &quot;Return air mass flow rate&quot; annotation (Dialog(group=&quot;Nominal condition&quot;)); parameter Modelica.Units.SI.MassFlowRate mChiWat_flow_nominal &quot;Total CHW mass flow rate&quot; annotation (Dialog(group=&quot;Nominal condition&quot;)); parameter Modelica.Units.SI.MassFlowRate mHeaWat_flow_nominal &quot;Total HHW mass flow rate&quot; annotation (Dialog(group=&quot;Nominal condition&quot;)); parameter Modelica.Units.SI.HeatFlowRate QChiWat_flow_nominal &quot;Total CHW heat flow rate&quot; annotation (Dialog(group=&quot;Nominal condition&quot;)); parameter Modelica.Units.SI.HeatFlowRate QHeaWat_flow_nominal &quot;Total HHW heat flow rate&quot; annotation (Dialog(group=&quot;Nominal condition&quot;)); Copy Templates/AirHandlersFans/Interfaces/PartialAirHandler.mo mo final parameter Modelica.Units.SI.MassFlowRate mAirSup_flow_nominal= dat.mAirSup_flow_nominal &quot;Supply air mass flow rate&quot; annotation (Dialog(group=&quot;Nominal condition&quot;)); final parameter Modelica.Units.SI.MassFlowRate mAirRet_flow_nominal= dat.mAirRet_flow_nominal &quot;Return air mass flow rate&quot; annotation (Dialog(group=&quot;Nominal condition&quot;)); parameter Modelica.Units.SI.MassFlowRate mChiWat_flow_nominal &quot;Total CHW mass flow rate&quot; annotation (Dialog(group=&quot;Nominal condition&quot;)); parameter Modelica.Units.SI.MassFlowRate mHeaWat_flow_nominal &quot;Total HHW mass flow rate&quot; annotation (Dialog(group=&quot;Nominal condition&quot;)); parameter Modelica.Units.SI.HeatFlowRate QChiWat_flow_nominal &quot;Total CHW heat flow rate&quot; annotation (Dialog(group=&quot;Nominal condition&quot;)); parameter Modelica.Units.SI.HeatFlowRate QHeaWat_flow_nominal &quot;Total HHW heat flow rate&quot; annotation (Dialog(group=&quot;Nominal condition&quot;)); Copy And the derived class: Templates/AirHandlersFans/VAVMultiZone.mo mo extends Buildings.Templates.AirHandlersFans.Interfaces.PartialAirHandler( ... final mChiWat_flow_nominal=if coiCoo.have_sou then dat.coiCoo.mWat_flow_nominal else 0, final mHeaWat_flow_nominal=(if coiHeaPre.have_sou then dat.coiHeaPre.mWat_flow_nominal else 0) + (if coiHeaReh.have_sou then dat.coiHeaReh.mWat_flow_nominal else 0), final QChiWat_flow_nominal=if coiCoo.have_sou then dat.coiCoo.Q_flow_nominal else 0, final QHeaWat_flow_nominal=(if coiHeaPre.have_sou then dat.coiHeaPre.Q_flow_nominal else 0) + (if coiHeaReh.have_sou then dat.coiHeaReh.Q_flow_nominal else 0)); Copy Templates/AirHandlersFans/VAVMultiZone.mo mo extends Buildings.Templates.AirHandlersFans.Interfaces.PartialAirHandler( ... final mChiWat_flow_nominal=if coiCoo.have_sou then dat.coiCoo.mWat_flow_nominal else 0, final mHeaWat_flow_nominal=(if coiHeaPre.have_sou then dat.coiHeaPre.mWat_flow_nominal else 0) + (if coiHeaReh.have_sou then dat.coiHeaReh.mWat_flow_nominal else 0), final QChiWat_flow_nominal=if coiCoo.have_sou then dat.coiCoo.Q_flow_nominal else 0, final QHeaWat_flow_nominal=(if coiHeaPre.have_sou then dat.coiHeaPre.Q_flow_nominal else 0) + (if coiHeaReh.have_sou then dat.coiHeaReh.Q_flow_nominal else 0)); Copy ","version":"Next","tagName":"h3"},{"title":"Both the Configuration Record and Locally Accessible Configuration Parameters​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#configuration-record","content":"The configuration parameters are declared in the interface class, as is the configuration record cfg which &quot;groups&quot; them into a single object more suitable for propagation. This record instance is not needed directly within a template class, but rather serves to reduce the number of parameter bindings when using a top-level parameter record (for all HVAC systems) that must access the configuration parameters of each template instance. It can be considered as the &quot;signature&quot; for a given system configuration, accessible within any template. The instance cfg must be ultimately assigned the final keyword, as it should not be exposed to the user. Contrary to design and operating parameters, the configuration parameters are propagated (with final bindings) from the component model to the record instance. Example Templates/AirHandlersFans/Interfaces/PartialAirHandler.mo mo replaceable parameter Buildings.Templates.AirHandlersFans.Configuration.PartialAirHandler cfg( final typ=typ, final typFanSup=typFanSup, final typFanRel=typFanRel, final typFanRet=typFanRet, final have_souChiWat=have_souChiWat, final have_souHeaWat=have_souHeaWat) &quot;Configuration parameters&quot;; parameter Buildings.Templates.AirHandlersFans.Types.Configuration typ &quot;Type of system&quot; annotation (Evaluate=true, Dialog(group=&quot;Configuration&quot;)); parameter Boolean have_porRel= typ==Buildings.Templates.AirHandlersFans.Types.Configuration.ExhaustOnly &quot;Set to true for relief (exhaust) fluid port&quot; annotation (Evaluate=true, Dialog(group=&quot;Configuration&quot;, enable=false)); parameter Boolean have_souChiWat &quot;Set to true if system uses CHW&quot; annotation (Evaluate=true, Dialog(group=&quot;Configuration&quot;)); parameter Boolean have_souHeaWat &quot;Set to true if system uses HHW&quot; annotation (Evaluate=true, Dialog(group=&quot;Configuration&quot;)); inner parameter Buildings.Templates.Components.Types.Fan typFanSup &quot;Type of supply fan&quot; annotation (Evaluate=true, Dialog(group=&quot;Configuration&quot;)); inner parameter Buildings.Templates.Components.Types.Fan typFanRet &quot;Type of return fan&quot; annotation (Evaluate=true, Dialog(group=&quot;Configuration&quot;)); inner parameter Buildings.Templates.Components.Types.Fan typFanRel &quot;Type of relief fan&quot; annotation (Evaluate=true, Dialog(group=&quot;Configuration&quot;)); Copy Templates/AirHandlersFans/Interfaces/PartialAirHandler.mo mo replaceable parameter Buildings.Templates.AirHandlersFans.Configuration.PartialAirHandler cfg( final typ=typ, final typFanSup=typFanSup, final typFanRel=typFanRel, final typFanRet=typFanRet, final have_souChiWat=have_souChiWat, final have_souHeaWat=have_souHeaWat) &quot;Configuration parameters&quot;; parameter Buildings.Templates.AirHandlersFans.Types.Configuration typ &quot;Type of system&quot; annotation (Evaluate=true, Dialog(group=&quot;Configuration&quot;)); parameter Boolean have_porRel= typ==Buildings.Templates.AirHandlersFans.Types.Configuration.ExhaustOnly &quot;Set to true for relief (exhaust) fluid port&quot; annotation (Evaluate=true, Dialog(group=&quot;Configuration&quot;, enable=false)); parameter Boolean have_souChiWat &quot;Set to true if system uses CHW&quot; annotation (Evaluate=true, Dialog(group=&quot;Configuration&quot;)); parameter Boolean have_souHeaWat &quot;Set to true if system uses HHW&quot; annotation (Evaluate=true, Dialog(group=&quot;Configuration&quot;)); inner parameter Buildings.Templates.Components.Types.Fan typFanSup &quot;Type of supply fan&quot; annotation (Evaluate=true, Dialog(group=&quot;Configuration&quot;)); inner parameter Buildings.Templates.Components.Types.Fan typFanRet &quot;Type of return fan&quot; annotation (Evaluate=true, Dialog(group=&quot;Configuration&quot;)); inner parameter Buildings.Templates.Components.Types.Fan typFanRel &quot;Type of relief fan&quot; annotation (Evaluate=true, Dialog(group=&quot;Configuration&quot;)); Copy And the derived class: Templates/AirHandlersFans/VAVMultiZone.mo mo extends Buildings.Templates.AirHandlersFans.Interfaces.PartialAirHandler( redeclare final Buildings.Templates.AirHandlersFans.Configuration.VAVMultiZone cfg( final typCoiHeaPre=coiHeaPre.typ, final typCoiCoo=coiCoo.typ, final typCoiHeaReh=coiHeaReh.typ, final typValCoiHeaPre=coiHeaPre.typVal, final typValCoiCoo=coiCoo.typVal, final typValCoiHeaReh=coiHeaReh.typVal, final typDamOut=secOutRel.typDamOut, final typDamOutMin=secOutRel.typDamOutMin, final typDamRet=secOutRel.typDamRet, final typDamRel=secOutRel.typDamRel, final typSecOut=secOutRel.typSecOut, final typCtl=ctl.typ, final buiPreCon=ctl.buiPreCon, final stdVen=ctl.stdVen), ...); Copy Templates/AirHandlersFans/VAVMultiZone.mo mo extends Buildings.Templates.AirHandlersFans.Interfaces.PartialAirHandler( redeclare final Buildings.Templates.AirHandlersFans.Configuration.VAVMultiZone cfg( final typCoiHeaPre=coiHeaPre.typ, final typCoiCoo=coiCoo.typ, final typCoiHeaReh=coiHeaReh.typ, final typValCoiHeaPre=coiHeaPre.typVal, final typValCoiCoo=coiCoo.typVal, final typValCoiHeaReh=coiHeaReh.typVal, final typDamOut=secOutRel.typDamOut, final typDamOutMin=secOutRel.typDamOutMin, final typDamRet=secOutRel.typDamRet, final typDamRel=secOutRel.typDamRel, final typSecOut=secOutRel.typSecOut, final typCtl=ctl.typ, final buiPreCon=ctl.buiPreCon, final stdVen=ctl.stdVen), ...); Copy This allows the top-level parameter record to access all configuration parameters of a VAV instance with a single binding as follows. Templates/AirHandlersFans/Validation/UserProject/Data/AllSystems.mo mo outer VAV VAV_1 &quot;Instance of MZVAV model&quot;; parameter Buildings.Templates.AirHandlersFans.Data.VAVMultiZone dat_VAV_1( final cfg=VAV_1.cfg, ...); Copy Templates/AirHandlersFans/Validation/UserProject/Data/AllSystems.mo mo outer VAV VAV_1 &quot;Instance of MZVAV model&quot;; parameter Buildings.Templates.AirHandlersFans.Data.VAVMultiZone dat_VAV_1( final cfg=VAV_1.cfg, ...); Copy ","version":"Next","tagName":"h3"},{"title":"Nested Expandable Connectors​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#nested-expandable-connectors","content":"The interface class of the main controller must have protected instances of all sub-buses, and these sub-bus instances must be connected to the corresponding variables from the main control bus as follows: Templates/ChilledWaterPlants/Components/Interfaces/PartialController.mo mo Buildings.Templates.ChilledWaterPlants.Interfaces.Bus bus &quot;Plant control bus&quot;; protected Buildings.Templates.Components.Interfaces.Bus busValChiWatChiIso[nChi] if typValChiWatChiIso&lt;&gt;Buildings.Templates.Components.Types.Valve.None &quot;Chiller CHW isolation valve control bus&quot;; equation connect(busValChiWatChiIso, bus.valChiWatChiIso) Copy Templates/ChilledWaterPlants/Components/Interfaces/PartialController.mo mo Buildings.Templates.ChilledWaterPlants.Interfaces.Bus bus &quot;Plant control bus&quot;; protected Buildings.Templates.Components.Interfaces.Bus busValChiWatChiIso[nChi] if typValChiWatChiIso&lt;&gt;Buildings.Templates.Components.Types.Valve.None &quot;Chiller CHW isolation valve control bus&quot;; equation connect(busValChiWatChiIso, bus.valChiWatChiIso) Copy This is particularly important in the case of array sub-buses. We avoid pre-declaring these sub-buses in the main bus definition because this would require including structural parameters for the array size inside the bus, and thus binding these parameters for each bus instance. Instead, we use instances of sub-buses in the interface class of the controller and the connect statement connect(bus&lt;Component&gt;, bus.&lt;component&gt;) allows Modelica compilers to assign the correct dimensions to bus.&lt;component&gt; (which is not predeclared in the bus definition). ","version":"Next","tagName":"h3"},{"title":"Components​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#components","content":"","version":"Next","tagName":"h2"},{"title":"Replaceable Component​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#replaceable-component","content":"No choicesAllMatching annotation is allowed in the Templates package (to maximize support across various Modelica tools). Expand into an explicit choices annotation with proper description strings and the following rules. Systematically use redeclare replaceable in the choices annotation to allow further redeclaration by the user,visiting the parameter dialog box of the redeclared component (this is Dymola's behavior, although this behavior is automatically enabled if the redeclared component contains replaceable components). ","version":"Next","tagName":"h3"},{"title":"Non-replaceable Component​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#non-replaceable-component","content":"If a composite component (such as a section) contains replaceable components, or components with configuration parameters that must be exposed, then it must be instantiated with the replaceable keyword so that ctrl-flow generates a parameter dialog for this component, and allows the user to specify the options for the nested components. This is true even if the type of the composite component is fixed. In this case, the component is still declared as replaceable, but without any choices annotation (e.g., section secOutRel in Templates/AirHandlersFans/VAVMultiZone.mo). ","version":"Next","tagName":"h3"},{"title":"Section​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#section","content":"A composite model that we call section is needed whenever there is a hard constraint on the allowed choices for two replaceable components that are on the same composition level. Example In the case of a multiple-zone VAV with an air economizer, a return fan should require a modulating relief damper. However, we cannot bind the redeclaration of the damper component to the redeclaration of the return fan component. So we introduce a section Templates.AirHandlersFans.Components.ReliefReturnSection that contains the two components, so that the whole section component can be redeclared with the proper inside fan and damper components. The interface class for a section must use the same class for the control bus as the one used by the system template. This is different from the base components, which have their own class for the control bus, as is implemented in Templates.Components.Interfaces.Bus. The motivation is to avoid nesting expandable connectors and to allow seamless traversal of the composition levels when connecting signal variables, see for example: Templates/AirHandlersFans/VAVMultiZone.mo mo connect(secOutRel.bus, bus); // secOutRel is a section (instance of OutdoorReliefReturnSection) connect(ctl.bus, bus); // ctl is a controller (instance of G36VAVMultiZone) Copy Templates/AirHandlersFans/VAVMultiZone.mo mo connect(secOutRel.bus, bus); // secOutRel is a section (instance of OutdoorReliefReturnSection) connect(ctl.bus, bus); // ctl is a controller (instance of G36VAVMultiZone) Copy Templates/AirHandlersFans/Components/OutdoorReliefReturnSection.mo mo connect(damRet.bus, bus.damRet); // connection to the damper bus inside the section Copy Templates/AirHandlersFans/Components/OutdoorReliefReturnSection.mo mo connect(damRet.bus, bus.damRet); // connection to the damper bus inside the section Copy Templates/AirHandlersFans/Components/Controls/G36VAVMultiZone.mo mo connect(ctl.yRetDamPos, bus.damRet.y); // accessing the damper control variable inside the controller Copy Templates/AirHandlersFans/Components/Controls/G36VAVMultiZone.mo mo connect(ctl.yRetDamPos, bus.damRet.y); // accessing the damper control variable inside the controller Copy ","version":"Next","tagName":"h3"},{"title":"Main Controller​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#main-controller","content":"The template is intended to be used by applications other than Modelica tools, such as ctrl-flow. To be compatible with these applications, the controller implementation must respect the following rules. ","version":"Next","tagName":"h2"},{"title":"Control Section​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#control-section","content":"All blocks that constitute the control sequence of a system are instantiated within a single component within the template. This component is referred to as the &quot;control section&quot; and is named ctl. It is similar to a section, see for example Templates.AirHandlersFans.Components.Controls.G36VAVMultiZone. The component ctl is not CDL-compliant due to the following reasons: It contains extends and redeclare statements.It may include inner and outer declarations. This remains true for the VAV templates, which were the first to be developed. However, the most recently developed templates have deprecated the use of inner and outer declarations, with the exception of the requirement stated below.Beyond the control section, to reference the configuration parameters from each configuration class prior to class instantiation, it is also necessary to include outer declarations within the top-level data record that stores the control parameter values. It uses expandable connectors.It may have an initial equation section.It employs non-permissible data types, such as Modelica.Units.SI.**.It assigns values to parameters using variables from the equipment model, which are outside the CDL scope. ","version":"Next","tagName":"h3"},{"title":"Control Parameters and Binding Equations​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#control-parameters-and-binding-equations","content":"In contrast to the CDL implementation of the SOO, we restrict the exposed parameters to the data that are scheduled in design documents by the design engineer, orprovided by the testing, adjusting, and balancing contractor, ordetermined by the control contractor. See ASHRAE (2021) Section 3 for typical required data. These parameters are propagated by means of the parameter record. Important Control parameters within the control section shall be assigned a value using only binding equations that involve expressions permitted in CDL: see https://obc.lbl.gov/specification/cdl.html#parameter-declaration-and-assigning-of-values-to-parameters. ","version":"Next","tagName":"h3"},{"title":"Control Point Connections​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#control-point-connections","content":"All connect clauses between the control blocks within ctl have a graphical annotation (so there are visible connection lines representing those connections). Most of the other connect clauses have no graphical annotation — typically the connection to a sensor or actuator signal — as this would overload the diagram view. Instead, a dedicated section is used at the top of the equation section. Templates/AirHandlersFans/VAVMultiZone.mo mo equation /* Control point connection - start */ // Inputs from AHU bus connect(bus.pAirSup_rel, ctl.dpDuc); connect(bus.TOut, ctl.TOut); ... // Inputs from terminal bus connect(busTer.yReqZonPreRes, reqZonPreRes.u); connect(busTer.yReqZonTemRes, reqZonTemRes.u); ... // Outputs to AHU bus connect(ctl.yMinOutDam, bus.damOutMin.y); connect(ctl.y1MinOutDam, bus.damOutMin.y1); ... // Outputs to terminal unit bus connect(TAirSupSet.y, busTer.TAirSupSet); connect(TAirSup.y, busTer.TAirSup); ... /* Control point connection - stop */ Copy Templates/AirHandlersFans/VAVMultiZone.mo mo equation /* Control point connection - start */ // Inputs from AHU bus connect(bus.pAirSup_rel, ctl.dpDuc); connect(bus.TOut, ctl.TOut); ... // Inputs from terminal bus connect(busTer.yReqZonPreRes, reqZonPreRes.u); connect(busTer.yReqZonTemRes, reqZonTemRes.u); ... // Outputs to AHU bus connect(ctl.yMinOutDam, bus.damOutMin.y); connect(ctl.y1MinOutDam, bus.damOutMin.y1); ... // Outputs to terminal unit bus connect(TAirSupSet.y, busTer.TAirSupSet); connect(TAirSup.y, busTer.TAirSup); ... /* Control point connection - stop */ Copy Note that the control section uses the same class for the control bus as the one used by the system template. tip Use the same name for the signal variable and for the component it originates from. Inside the control section, connections to variables within nested expandable connectors should be done by means of the local instances of sub-buses to guarantee that Modelica compilers assign correct dimensions to these variables. See the example in Gautier (2023) Section 5. See also: Templates/ChilledWaterPlants/Components/Controls/G36.mo mo equation /* Control point connection - start */ connect(busChi.y1ChiWatReq, ctl.uChiWatReq); // as opposed to connect(bus.chi.y1ChiWatReq, ctl.uChiWatReq) Copy Templates/ChilledWaterPlants/Components/Controls/G36.mo mo equation /* Control point connection - start */ connect(busChi.y1ChiWatReq, ctl.uChiWatReq); // as opposed to connect(bus.chi.y1ChiWatReq, ctl.uChiWatReq) Copy ","version":"Next","tagName":"h3"},{"title":"Equipment Status​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#equipment-status","content":"An ad hoc component has been developed to emulate the equipment status and should be used systematically. The only exception applies to equipment models (like Fluid.Actuators.Dampers.Exponential) that already provide a feedback signal as an output (for example y_actual for actuator and mover models). However, if use_inputFilter=false then y_actual is directly connected to the input signal y, potentially creating an algebraic loop if the control logic uses the equipment status. Open Issue Switching to using StatusEmulator instead of y_actual if use_inputFilter=false is being implemented through #3499. ","version":"Next","tagName":"h3"},{"title":"Parameter Record​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#parameter-record","content":"All design and operating parameters are declared within a Modelica record class. This record is used to assign design and operating parameter values for all subcomponents,support parameter propagation from a top-level, whole HVAC system parameter record,populate the equipment schedule in the UI. ","version":"Next","tagName":"h2"},{"title":"Implementation Rules​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#implementation-rules","content":"Subrecord with Configuration Parameters​ Within the parameter record, all configuration parameters are (only) accessible via an instance of the configuration record cfg. This instance uses the annotation annotation (Dialog(enable=false)) as it should not be exposed to the user—and record classes do not allow for protected elements, and this instance cannot be final as it is overridden. note The final override is debatable and the bindings of record instances containing final parameter assignments appear to be under-specified. As a result, the behavior varies across Modelica tools. And even for a given tool, it varies with the constructs being used (such as inheritance or direct definition). Dymola sometimes (see SRF00860858) triggers a &quot;final overriding&quot; error when a record instance contains final bindings and the record itself is propagated from a higher composition level. OCT never yields a warning. When instantiated within the interface class, the parameter record uses a binding with the local instance of the configuration record, i.e., dat(cfg=cfg). Here again, because this binding will be overridden when propagated dat from a top-level whole-building record, the final keyword must not be used in this binding. Parameter Propagation​ Parameter propagation is implemented as follows. Configuration parameters are assigned from the component model to the record, and propagated up the instance tree.Design and operating parameters are assigned from the record to the component model, and propagated down the instance tree. The record for the controller section needs to be instantiated (not extended) in the master record because it requires many configuration parameters (such as typFanSup) that have duplicates in the master record. At the component level, we instantiate the parameter record as dat and bind (with final) local design and operating parameters to the record elements. Details This implementation is similar to the one from Fluid.Chillers.ElectricEIR. However, other classes such as Fluid.Actuators.BaseClasses.PartialTwoWayValve extend the parameter class Fluid.Actuators.BaseClasses.ValveParameters to integrate the parameter definitions in a flat structure. This allows simpler propagation (only the record is passed in) which is agnostic from the parameter structure of the constraining class (for example mWat_flow_nominal is not defined in Templates.Components.Coils.Interfaces.PartialCoil). Use Only One Nesting Level​ If needed, component records must extend (not instantiate) subcomponent records. For example in Templates.Components.Coils.Interfaces.Data: the class cannot extend Templates.Components.Valves.Interfaces.Data because of the colliding declarations of typ,so dpValve_nominal is declared locally and a protected record with the type Templates.Components.Valves.Interfaces.Data is constructed to pass in parameters to the valve component. ","version":"Next","tagName":"h3"},{"title":"Exposed Parameters​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#exposed-parameters","content":"Design and Operating Parameters​ In addition to the configuration parameters, the record contains all design and operating parameters required by the sequence of operation for all possible system configurations, see ASHRAE (2021) Section 3,for sizing equipment models (most of these parameters are already included in 1.). Modeling and parameters from the &quot;Advanced&quot; dialog tab shall not be included in this record. The record should be viewed as a digital avatar of the manufacturer’s data sheet for a given system, and as such, should only contain equipment and control parameters that HVAC designers are familiar with. The set of required parameters depends on the actual system configuration. However, MLS does not allow parameters to be conditionally instantiated. (More precisely, conditional components can only be used in connect statements, which prevents the use of conditional parameters.) As a workaround, we use parameter declarations with an enable annotation, andan explicit start attribute. Details From the language specification: If enable = false, the input field may be disabled and no input can be given. In our case, if the enable attribute evaluates to false, these parameters are actually not used in the flat equation system — after removing the conditional components with false condition and taking into account all redeclarations. We use the start attribute to provide a &quot;placeholder&quot; value that has no impact whatsoever on the simulation results. For more details, refer to Section 6.2 and Listing 2 of Gautier (2023). System Tags​ System tags are optional parameters that are not used for simulation but nevertheless included in the parameter record of each template to support future workflow automation (e.g., parameterization of a template by means of an external equipment schedule). Templates/AirHandlersFans/Data/PartialAirHandler.mo mo parameter String id=&quot;&quot; &quot;System tag&quot; annotation (Dialog(tab=&quot;Advanced&quot;)); parameter String id_souChiWat=&quot;&quot; &quot;CHW supply system tag&quot; annotation (Dialog(tab=&quot;Advanced&quot;, enable=have_souChiWat)); parameter String id_souHeaWat=&quot;&quot; &quot;HHW supply system tag&quot; annotation (Dialog(tab=&quot;Advanced&quot;, enable=have_souHeaWat)); Copy Templates/AirHandlersFans/Data/PartialAirHandler.mo mo parameter String id=&quot;&quot; &quot;System tag&quot; annotation (Dialog(tab=&quot;Advanced&quot;)); parameter String id_souChiWat=&quot;&quot; &quot;CHW supply system tag&quot; annotation (Dialog(tab=&quot;Advanced&quot;, enable=have_souChiWat)); parameter String id_souHeaWat=&quot;&quot; &quot;HHW supply system tag&quot; annotation (Dialog(tab=&quot;Advanced&quot;, enable=have_souHeaWat)); Copy ","version":"Next","tagName":"h3"},{"title":"System Schematic​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#system-schematic","content":"Refer to the specification for the generation of engineering schematics if needed. ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#example","content":"Below is an illustration of the kind of schematic (or control diagram) we want to generate, taken from Templates.HeatingPlants.HotWater.Validation.BoilerPlant in branch issue3266_template_HW_plant, using Dymola's feature &quot;Show Component&quot;.  ","version":"Next","tagName":"h3"},{"title":"Component Icons​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#component-icons","content":"Modelica tool support Currently the SVG graphics integrated using class annotations such as Icon(graphics={Bitmap(fileName=&lt;svg-file-path&gt;, visible=&lt;boolean-expression&gt;)) are not supported by Modelon Impact: ticket open at Modelon#2022042039000931 on the roadmap for the 2023.1 release,not fully supported by OMEdit: most likely due to &lt;boolean-expression&gt; not being evaluated at UI runtime,entirely supported by Dymola &gt;=2022.x. The master SVG document containing all raw icons provided by Taylor Engineering and used in ASHRAE (2021) is currently located at Resources/Images/Templates/Icons.svg. Those raw icons must be processed as described below for Inkscape &gt;=1.1 before being used in the icon layers of Modelica classes. Details The requirements below stem from the following observations. The Modelica Language Specification specifies type DrawingUnit = Real(final unit=&quot;mm&quot;).The default icon layer size in Dymola is 200×200200 \\times 200200×200 mm ({{-100,-100},{100,100}}). This corresponds to 10×1010 \\times 1010×10 cells in the icon view. So one cell corresponds to 20×2020 \\times 2020×20 mm.When instantiated, a component has its icon scaled by a factor 1/101/101/10 in the diagram layer. For example, a Line object with thickness=5 in the icon layer is rendered as a Line object with thickness=0.5 in the diagram layer.When thickness &lt; 0.25, the stroke width remains unchanged in Dymola: so 0.20.20.2 and 0.10.10.1 yield the same stroke width.It seems that Dymola handles Bitmap objects as squares, i.e., the objects are scaled by the minimum of the x and y dimensions. Having external SVG files with equal height and width makes it easier to position and scale the graphical objects. Select object, copy to new file.Change stroke color to black and stroke width to 111 mm.Account for 202020 mm for each grid cell in Dymola icon layer. So the default icon layer size of 10×1010 \\times 1010×10 cells in Dymola corresponds to a page size of 200×200200 \\times 200200×200 mm in Inkscape. For most of the AHU components, lock width/height ratio and change height to 200200200 mm. For transducers, 200200200 mm is for the probe, 808080 mm is for the sensor casing. For polygons, the different segments will typically not be connected together (gap at each corner), so select each segment with Node tool and use Node functionalities to Convert selected objects to pathJoin selected nodesFor the last corner use Path/Union Text should be in sans-serif with font size of 120120120. If needed (typically in case of specific text orientation), select text object and transform to path with Path/Object to Path. Set the page size with the same height and width (typically 200×200200 \\times 200200×200 mm) and center icons in the page.Save as Inkscape SVG. ","version":"Next","tagName":"h3"},{"title":"Graphical Primitives​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#graphical-primitives","content":"In addition to external SVG files, the schematics may use Modelica graphical primitives with the following conventions. Equipment\tPrimitive\tIcon layer\tDiagram layerSupply pipe (*)\tLine, solid\tThickness 0.50.50.5\tThickness 555 Return pipe (*)\tLine, dashed\tThickness 0.50.50.5\tThickness 555 Duct wall\tLine, solid\tDefault thickness (0.250.250.25)\tDefault thickness (0.250.250.25) Capillary tube (pressure sensor)\tPolygon or rectangle\tDefault thickness (0.250.250.25), width 101010\tDefault thickness (0.250.250.25), width 111 Motor shaft (actuator), connection between sensor and transmitter\tLine, solid\tDefault thickness (0.250.250.25)\tDefault thickness (0.250.250.25) (*) This should be specified as a graphical annotation to the corresponding connect statement. Graphical primitives that need to be pruned to generate the system schematic shall use the annotation visible=viewDiagramAll where viewDiagramAll is declared in the template interface class with: mo inner parameter Boolean viewDiagramAll=false &quot;Set to true to view all component icons in diagram view&quot; annotation (Dialog(tab=&quot;Graphics&quot;)); Copy mo inner parameter Boolean viewDiagramAll=false &quot;Set to true to view all component icons in diagram view&quot; annotation (Dialog(tab=&quot;Graphics&quot;)); Copy ","version":"Next","tagName":"h3"},{"title":"Vendor Specific Annotations​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#vendor-specific-annotations","content":"Vendor annotations are either hierarchical annotations in the form of &quot;__ctrlFlow&quot; class-modification, using strict camel case formatting for any argument in the class modification, orsimple annotations in the form of &quot;__ctrlFlow&quot; &quot;_&quot; IDENT. ","version":"Next","tagName":"h2"},{"title":"Class Annotations​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#class-annotations","content":"__ctrlFlow_template​ Ctrl-flow searches for this annotation and returns a list of files which are then treated as entry points to build the tree of system types. Both packages (corresponding to system types such as Templates.AirHandlersFans) and template classes (such as Templates.AirHandlersFans.VAVMultiZone) shall contain this annotation. So the file arborescence: sh Templates ├── AirHandlersFans │ ├── ... │ ├── package.mo # Contains __ctrlFlow_template annotation │ └── VAVMultiZone.mo # Contains __ctrlFlow_template annotation ├── Components │ └── ... ├── Data │ ├── AllSystems.mo │ ├── package.mo │ └── ... ├── package.mo ├── package.order ├── Types.mo ├── UsersGuide.mo └── ZoneEquipment ├── ... ├── package.mo # Contains __ctrlFlow_template annotation ├── VAVBoxCoolingOnly.mo # Contains __ctrlFlow_template annotation └── VAVBoxReheat.mo # Contains __ctrlFlow_template annotation Copy sh Templates ├── AirHandlersFans │ ├── ... │ ├── package.mo # Contains __ctrlFlow_template annotation │ └── VAVMultiZone.mo # Contains __ctrlFlow_template annotation ├── Components │ └── ... ├── Data │ ├── AllSystems.mo │ ├── package.mo │ └── ... ├── package.mo ├── package.order ├── Types.mo ├── UsersGuide.mo └── ZoneEquipment ├── ... ├── package.mo # Contains __ctrlFlow_template annotation ├── VAVBoxCoolingOnly.mo # Contains __ctrlFlow_template annotation └── VAVBoxReheat.mo # Contains __ctrlFlow_template annotation Copy yields the following UI objects:  Alternative Approach Discussed With DEPT but Not Implemented We should rather use a flag indicating that a package (in our case Templates) is to be considered as the &quot;root&quot; for all template URIs, for example: __ctrlFlow(routing=&quot;root&quot;). And for each template class (for example Templates.AirHandlersFans.VAVMultiZone): __ctrlFlow(routing=&quot;template&quot;). The contract for the template developer will then be that the class URI dictates the explorer tree structure, starting from the &quot;root&quot; package (necessarily unique inside a library). For example, the template Templates.AirHandlersFans.VAVMultiZone with the above annotation would yield the following tree structure. sh AirHandlersFans └── VAVMultiZone Copy sh AirHandlersFans └── VAVMultiZone Copy Without having to add any annotation to the subpackage Templates.AirHandlersFans. So we would implicitly consider each folder between routing=&quot;template&quot; and routing=&quot;root&quot; to be a template category (like &quot;Air Handlers and Fans&quot;). ","version":"Next","tagName":"h3"},{"title":"Declaration Annotations​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#declaration-annotations","content":"__ctrlFlow(enable=true|false)​ Each declaration or extends statement may have a hierarchical annotation &quot;__ctrlFlow&quot; &quot;(&quot; &quot;enable&quot; &quot;=&quot; logical-expression &quot;)&quot; that allows disabling input fields in the ctrl-flow configuration dialog. This is similar to the Modelica annotation Dialog(enable=true|false) but provides additional flexibility and allows disabling all parameter input fields that are brought in by an extends statement. It takes precedence over the standard annotation Dialog(enable). Typical use cases include classes from the Modelica Buildings Library that contain definitions of detailed simulation parameters and that are extended to define template components, or package classes used to specify the fluid properties. Boolean Literal or Expression? Although only Boolean literals are used in the templates as of commit 675801b669, the expression evaluation engine is invoked when parsing __ctrlFlow(enable...), see https://github.com/lbl-srg/ctrl-flow-dev/blob/e2bb34ca76e0d1ed7413691a89ffd8525e16c750/server/src/parser/parser.ts#L296-L317. So in practice, Boolean expressions could be used. ","version":"Next","tagName":"h3"},{"title":"Code Base​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#code-base","content":"","version":"Next","tagName":"h2"},{"title":"Git Workflow​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#git-workflow","content":"Each new development should start by branching out from the master branch of the Modelica Buildings Library. ","version":"Next","tagName":"h3"},{"title":"Code Tags​","type":1,"pageTitle":"Guide","url":"/modelica-buildings-templates/guide#code-tags","content":"The development of templates usually requires several iterations with the author of the CDL implementation of the SOO. This takes time. Code tags have proven useful in this context. We adopt the code tags from PEP 350 to reference issues and feature enhancements directly in the Modelica code base. All tags should include one of the tag names below in all caps, followed by the name, e-mail address, or other identifier of the person with the best context about the problem, and the GH issue number if available. We keep it simple and only use: BUG for what prevents from translating or simulating a model: should prevent mergingFIXME for any problematic code not suitable for production: should prevent merging, include PEP 350 TODO under that code tagHACK mainly for workarounds related to Modelica tools' limitations: reference the ticket number from the Modelica tool provider if availableRFE for a clearly identified development need (as opposed to an idea) For example: mo // FIXME(AntoineGautier #1913): Should be conditional, depending on have_fanRel. Copy mo // FIXME(AntoineGautier #1913): Should be conditional, depending on have_fanRel. Copy So we can collect all code tags with: sh grep -nER '(^|/(\\*|/)|&lt;!--|&quot;)\\s*(BUG|FIXME|HACK|RFE)' Templates/. Copy sh grep -nER '(^|/(\\*|/)|&lt;!--|&quot;)\\s*(BUG|FIXME|HACK|RFE)' Templates/. Copy ","version":"Next","tagName":"h3"}]